package model;


import java.util.HashMap;
import java.util.List;


import java.io.FileOutputStream;
import java.io.FileInputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import io.MyCompressorOutputStream;
import io.MyDecompressorInputStream;


import controller.Controller;


import algorithms.demo.SearchableAdapter;
import algorithms.mazeGenarators.*;
import algorithms.search.*;


public class MyModel implements Model{

	private HashMap<String,Solution<Position>> solution_hashmap = new HashMap<String, Solution<Position>>();
	private HashMap<String,Maze3d> maze3d_hashmap = new HashMap<String, Maze3d>();
	Controller control;
	
	public Controller getControl() {
		return control;
	}
	public void setControl(Controller c) {
		this.control = c;
	}
	
	@Override
	public void dir(File dir) {
		String[] array;
		 if(dir.exists())
		 {
			 array = dir.list();
			 control.viewResults(array);
		 }
		 else
		 {
			 System.out.println("The directory " + dir.getPath() + " is not accessible");
		 }
	}

	@Override
	public void getCrossBY(String name, int index, char by) {
		if(maze3d_hashmap.containsKey(name)){
			try{
				int[][] crossby = new int[0][0];
				System.out.println("HI");
				switch(by){
				case 'x':
					crossby = maze3d_hashmap.get(name).getCrossSectionByX(index);
					break;
				case 'y':
					crossby = maze3d_hashmap.get(name).getCrossSectionByY(index);
					break;
				case 'z':
					crossby = maze3d_hashmap.get(name).getCrossSectionByZ(index);
					break;
				default:
					control.viewResults("There is no such place as " + by);
				}
				
				control.viewResults(crossby);
			}catch(IndexOutOfBoundsException e){
				e.printStackTrace();
			}
		}else{
			control.viewResults("There is no such maze as " + name);
			
		}
	}

	@Override
	public void generateM3d(String name, int lev, int row, int col, String alg) {
		Maze3d maze3d = null;
		Maze3dGenerator m3dg = null;

		switch(alg){
		case "Simple":
			m3dg = new SimpleMaze3dGenerator();
			maze3d = m3dg.generate(lev, row, col);
			maze3d_hashmap.put(name, maze3d);
			control.viewResults("The maze "+name+" has been generated by simple algorithm");
			break;
		case "Growing":
			m3dg = new GrowingTreeGenerator();
			maze3d = m3dg.generate(lev, row, col);
			maze3d_hashmap.put(name, maze3d);
			control.viewResults("The maze "+name+" has been generated by growing tree algoritm");
			break;
		default:
			control.viewResults("There is no such algorithm as " + alg);
		}
	}

	@Override
	public void display(String name) {
		if(maze3d_hashmap.containsKey(name)){
			control.viewResults(maze3d_hashmap.get(name).toString());
		}else{
			control.viewResults("There is no such maze as " + name);
		}
	}

	@Override
	public void saveM3d(FileOutputStream fout, String name) {
		if(maze3d_hashmap.containsKey(name)){
			OutputStream out = new MyCompressorOutputStream(fout);
			
			try {
				out.write(maze3d_hashmap.get(name).toByteArray());
				out.flush();
				out.close();
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}else{
			control.viewResults("There is no such maze as " + name);
		}
		
	}

	@Override
	public void loadM3d(FileInputStream fin, String name) {
		MyDecompressorInputStream myin = new MyDecompressorInputStream( fin );

		int size = 0;
		try {
			size = myin.getSize();
		} catch (IOException e1) {
			e1.printStackTrace();
		}
		
		byte b[] = new byte[size];
		
		try {
			myin.read(b);
			myin.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		Maze3d maze3d = new Maze3d(b);
		maze3d_hashmap.put(name, maze3d);
		
	}
	
	@Override
	public void solveM3d(String name, String alg) {
		if(maze3d_hashmap.containsKey(name)){
			SearchableAdapter mySa = new SearchableAdapter(maze3d_hashmap.get(name));
			if(alg.equals("BFS")){
				Searcher<Position> bfs = new BFS<Position>();
				Solution<Position> solution = bfs.search(mySa);
				solution_hashmap.put(name, solution);
				control.viewResults("The maze "+name+" is solved by BFS");
			}else if(alg.equals("DFS")){
				Searcher<Position> dfs = new BFS<Position>();
				Solution<Position> solution = dfs.search(mySa);
				solution_hashmap.put(name, solution);
				control.viewResults("The maze "+name+" is solved by DFS");
			}else{
				control.viewResults("There is no such algorithm as " + alg);
			}
		}else{
			control.viewResults("There is no such maze as " + name);
		}
	}

	@Override
	public void displaySolution(String name) {
		if(solution_hashmap.containsKey(name)){
			List<State<Position>> positions = solution_hashmap.get(name).getStates();
			for( State<Position> pos : positions){
				control.viewResults(pos.getVal().toString());
			}
		}else{
			control.viewResults("There is no such solution as " + name);
		}
	}

	@Override
	public void exit() {
		control.viewResults("Thanks for using Valery's and Yarden's program!");
		
	}
}
