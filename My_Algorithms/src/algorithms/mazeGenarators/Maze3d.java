package algorithms.mazeGenarators;

import algorithms.mazeGenarators.Position;

import java.util.ArrayList;

/**
 * @author Tal Mishaan 203908652 & Guy Binyamin 200958098
 *
 */
public class Maze3d {
	private int[][][] maze3d;
	private int levels;
	private int rows;
	private int columns;
	private Position start;
	private Position goal;
	
	public final int FREE = 0;
	public final int WALL = 1;

	/**
	 * Constructor
	 * @param maze3d int[][][] 3d integer array
	 */
	public Maze3d(int[][][] maze3d) {
		super();
		this.maze3d = maze3d;
	}
	/**
	 * Constructor
	 * @param level int This is the maze level number
	 * @param row int This is the maze row number
	 * @param col int This is the maze column number
	 */
	public Maze3d(int level, int row, int col) {
		super();
		levels = level;
		rows = row;
		columns = col;
		
		this.maze3d = new int[levels][rows][columns];
		
//		for (int[][] z : this.maze3d)
//			for(int[] y : z)
//				Arrays.fill(y, 1);
		
	}	
	/**
	 * This method is a constructor to make Maze3d from byte array
	 * @param byte_array This is byte array generated by this.toByteArray
	 */
	public Maze3d(byte[] byte_array){
		int[] b = new int[byte_array.length];
		
		for (int i = 0; i < b.length; i++) {
			b[i] = (int) byte_array[i];
		}
		
		levels = b[0];
		rows = b[1];
		columns = b[2];
		
		start = new Position(b[3], b[4], b[5]);
		goal = new Position(b[6], b[7], b[8]);
		
		this.maze3d = new int[levels][rows][columns];
		
		int count = 9;
		for(int l = 0; l < levels; l++){
			for(int r = 0; r < rows; r++){
				for(int c = 0; c < columns; c++){
					this.maze3d[l][r][c] = b[count];
					count++;
				}
			}
		}
	}
	
	/**
	 * This method is to get Maze3d object
	 * @return int[][][] This returns the maze3d object
	 */
	public int[][][] getMaze3d() {
		return maze3d;
	}
	/**
	 * This method returns level number
	 * @return int levels number
	 */
	public int getLevels() {
		return levels;
	}
	/**
	 * This method returns row number
	 * @return int rows number
	 */
	public int getRows() {
		return rows;
	}
	/**
	 * This method returns column number
	 * @return int columns number
	 */
	public int getColumns() {
		return columns;
	}
	/**
	 * This gets specific point in the maze and returns it's value
	 * @param level This is given level
	 * @param row This is given row
	 * @param col This is given column
	 * @return int This returns if position is wall or free
	 */
	public int getValue(int level, int row, int col){
		return this.maze3d[level][row][col];
	}
	/**
	 * This method returns maze start position
	 * @return Position This returns start position
	 */
	public Position getStartPosition() {
		return start;
	}
	/**
	 * This method returns maze goal position
	 * @return Position This returns goal position
	 */
	public Position getGoalPosition() {
		return goal;
	}
	/**
	 * This method is used to get possible ways from a Position
	 * @param p This is the Position wanted
	 * @return ArrayList<Position> This returns a list
	 * of the nearby free Positions
	 */
	public ArrayList<Position> getPossibleMoves(Position p){
		ArrayList<Position> possible_moves = new ArrayList<Position>();
		int level = p.getLevel();
		int row = p.getRow();
		int col = p.getColm();
		
		if((level+1 < this.levels) && getValue(level+1, row, col) == 0){
			possible_moves.add(new Position(level+1, row, col)); // Up
		}
		if((level-1 >= 0) && getValue(level-1, row, col) == 0){
			possible_moves.add(new Position(level-1, row, col)); // Down
		}
		if((row+1 < this.rows) && getValue(level, row+1, col) == 0){
			possible_moves.add(new Position(level, row+1, col)); // Forward
		}
		if((row-1 < this.rows) && getValue(level, row-1, col) == 0){
			possible_moves.add(new Position(level, row-1, col)); // Backward
		}
		if((col+1 < this.columns) && getValue(level, row, col+1) == 0){
			possible_moves.add(new Position(level, row, col+1)); // Right
		}
		if((col-1 < this.columns) && getValue(level, row, col-1) == 0){
			possible_moves.add(new Position(level, row, col-1)); // Left
		}
		
		return possible_moves;
	}
	/**
	 * This method is use to get 2d int of specific column
	 * @param x This is the column (x dimension)
	 * @return int[][] This returns 2d int
	 * of the levels and rows of a column
	 */
	public int[][] getCrossSectionByX(int x){
		if(x < columns && x >= 0){
			int[][] maze2d = new int[levels][rows];
			
			for (int i = 0; i < levels; i++) {
				for (int j = 0; j < rows; j++) {
					maze2d[i][j] = this.getValue(i, j, x);
				}
			}
			
			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	/**
	 * This method is use to get 2d int of specific row
	 * @param y This is the row (y dimension)
	 * @return int[][] This returns 2d int
	 * of the levels and columns of a row
	 */
	public int[][] getCrossSectionByY(int y){
		if(y < rows && y >= 0){
			int[][] maze2d = new int[levels][columns];
			
			for (int i = 0; i < levels; i++) {
				for (int j = 0; j < columns; j++) {
					maze2d[i][j] = this.getValue(i, y, j);
				}
			}

			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	/**
	 * This method is use to get 2d int of specific level
	 * @param z This is the level (z dimension)
	 * @return int[][] This returns 2d int
	 * of the rows and columns of a level
	 */
	public int[][] getCrossSectionByZ(int z){
		if(z < levels && z >= 0){
			int[][] maze2d = new int[rows][columns];
			
			for (int i = 0; i < rows; i++) {
				for (int j = 0; j < columns; j++) {
					maze2d[i][j] = this.getValue(z, i, j);
				}
			}
			
			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	
	/**
	 * This method sets maze start position
	 * @param Position This is the start position
	 */
	public void setStartPosition(Position startPosition) {
		this.start = startPosition;
		this.setFree(startPosition);
	}
	/**
	 * This method sets maze goal position
	 * @param Position This is the goal position
	 */
	public void setGoalPosition(Position goalPosition) {
		this.goal = goalPosition;
	}
	/**
	 * This set the value of WALL in 1 point in the maze
	 * @param level This is the level wanted
	 * @param row This is the row wanted
	 * @param col This is the col wanted
	 */
	public void setWall(int level, int row, int col){
		this.maze3d[level][row][col] = WALL;
	}
	/**
	 * This method set the value WALL in 1 Position in the maze
	 * @param pos This is the Position wanted
	 */
	public void setWall(Position pos){
		this.maze3d[pos.getLevel()][pos.getRow()][pos.getColm()] = WALL;
	}
	/**
	 * This method set the value FREE in 1 point in the maze
	 * @param level This is the level wanted
	 * @param row This is the row wanted
	 * @param col This is the col wanted
	 */
	public void setFree(int level, int row, int col){
		this.maze3d[level][row][col] = FREE;
	}
	/**
	 * This method set the value FREE in 1 Position in the maze
	 * @param pos This is the Position wanted
	 */
	public void setFree(Position pos){
		this.maze3d[pos.getLevel()][pos.getRow()][pos.getColm()] = FREE;
	}
	/**
	 * This sets the maze object
	 * @param maze3d int[][][] This is the maze array
	 */
	public void setMaze3d(int[][][] maze3d) {
		this.maze3d = maze3d;
	}
	/**
	 * This method set the wanted value in 1 point in the maze
	 * @param level This is the wanted level
	 * @param row This is the wanted row
	 * @param col This is the wanted column
	 * @param value This is the wanted value
	 */
	public void setValue(int level, int row, int col, int value){
		this.maze3d[level][row][col] = value;
	}
	
	/**
	 * This method returns bytes list of the maze properties and structure
	 * Order of the list:
	 * levels, rows, columns,
	 * start level, start row, start column,
	 * end level, end row, end column
	 * than the value of [0][0][0], [0][0][1] ... [levels][rows][columns]
	 * @return byte[] This returns the list of data of the maze
	 */
	public byte[] toByteArray(){
		byte[] array = new byte[(3*3)+(levels*rows*columns)];
		array[0] = (byte) levels;
		array[1] = (byte) rows;
		array[2] = (byte) columns;
		array[3] = (byte) start.getLevel();
		array[4] = (byte) start.getRow();
		array[5] = (byte) start.getColm();
		array[6] = (byte) goal.getLevel();
		array[7] = (byte) goal.getRow();
		array[8] = (byte) goal.getColm();
		int count = 9;
		for(int l = 0; l < levels; l++){
			for(int r = 0; r < rows; r++){
				for(int c = 0; c < columns; c++){
					array[count]=(byte)maze3d[l][r][c];
					count++;
				}
			}
		}
		
		return array;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int h = 0; h < this.levels; h++){
			sb.append("\n\n");
			
			for (int i = 0; i < this.rows; i++) {
				for (int j = 0; j < this.columns; j++) {
					if(h == start.getLevel() && i == start.getRow() && j == start.getColm())
						sb.append("S ");
					else if(h == goal.getLevel() && i == goal.getRow() && j == goal.getColm())
						sb.append("X ");
					else
						sb.append(this.maze3d[h][i][j] + " ");
				}
				sb.append("\n");
			}
		}
		
		return sb.toString();
	}

	@Override
	public boolean equals(Object obj) {
		if(obj.getClass() == this.getClass()){
			Maze3d obj_cast = (Maze3d)obj;
			
			if(obj_cast.toString().equals(this.toString())){
				return true;
			}
		}
		return false;
	}
}
