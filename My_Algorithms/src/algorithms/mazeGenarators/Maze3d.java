package algorithms.mazeGenarators;

import algorithms.mazeGenarators.Position;
import java.util.ArrayList;

public class Maze3d {
	private int[][][] maze3d;
	private int levels;
	private int rows;
	private int columns;
	private Position start;
	private Position goal;
	
	public final int FREE = 0;
	public final int WALL = 1;

	public Maze3d(int[][][] maze3d) {
		super();
		this.maze3d = maze3d;
	}
	public Maze3d(int level, int row, int col) {
		super();
		levels = level;
		rows = row;
		columns = col;
		
		this.maze3d = new int[levels][rows][columns];
		
//		for (int[][] z : this.maze3d)
//			for(int[] y : z)
//				Arrays.fill(y, 1);
		
	}	
	/**
	 * This method is a constructor to make Maze3d from byte array
	 * @param byte_array This is byte array generated by this.toByteArray
	 */
	public Maze3d(byte[] byte_array){
		levels = byte_array[0];
		rows = byte_array[1];
		columns = byte_array[2];
		
		start = new Position(byte_array[3], byte_array[4], byte_array[5]);
		start = new Position(byte_array[6], byte_array[7], byte_array[8]);
		
		this.maze3d = new int[levels][rows][columns];
		
		int count = 9;
		for(int l = 0; l < levels; l++){
			for(int r = 0; r < rows; r++){
				for(int c = 0; c < columns; c++){
					maze3d[l][r][c] = byte_array[count];
					count++;
				}
			}
		}
	}
	
	public int[][][] getMaze3d() {
		return maze3d;
	}
	public int getLevels() {
		return levels;
	}
	public int getRows() {
		return rows;
	}
	public int getColumns() {
		return columns;
	}
	/**
	 * This gets specific point in the maze and returns it's value
	 * @param level This is given level
	 * @param row This is given row
	 * @param col This is given column
	 * @return int This returns if position is wall or free
	 */
	public int getValue(int level, int row, int col){
		return this.maze3d[level][row][col];
	}
	public Position getStartPosition() {
		return start;
	}
	public Position getGoalPosition() {
		return goal;
	}
	public ArrayList<Position> getPossibleMoves(Position p){
		ArrayList<Position> possible_moves = new ArrayList<Position>();
		int level = p.getLevel();
		int row = p.getRow();
		int col = p.getColm();
		
		if((level+1 < this.levels) && getValue(level+1, row, col) == 0){
			possible_moves.add(new Position(level+1, row, col)); // Up
		}
		if((level-1 >= 0) && getValue(level-1, row, col) == 0){
			possible_moves.add(new Position(level-1, row, col)); // Down
		}
		if((row+1 < this.rows) && getValue(level, row+1, col) == 0){
			possible_moves.add(new Position(level, row+1, col)); // Forward
		}
		if((row-1 < this.rows) && getValue(level, row-1, col) == 0){
			possible_moves.add(new Position(level, row-1, col)); // Backward
		}
		if((col+1 < this.columns) && getValue(level, row, col+1) == 0){
			possible_moves.add(new Position(level, row, col+1)); // Right
		}
		if((col-1 < this.columns) && getValue(level, row, col-1) == 0){
			possible_moves.add(new Position(level, row, col-1)); // Left
		}
		
		return possible_moves;
	}
	public int[][] getCrossSectionByX(int x){
		if(x < columns && x >= 0){
			int[][] maze2d = new int[levels][rows];
			
			for (int i = 0; i < levels; i++) {
				for (int j = 0; j < rows; j++) {
					maze2d[i][j] = this.getValue(i, j, x);
				}
			}
			
			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	public int[][] getCrossSectionByY(int y){
		if(y < rows && y >= 0){
			int[][] maze2d = new int[levels][columns];
			
			for (int i = 0; i < levels; i++) {
				for (int j = 0; j < columns; j++) {
					maze2d[i][j] = this.getValue(i, y, j);
				}
			}

			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	public int[][] getCrossSectionByZ(int z){
		if(z < levels && z >= 0){
			int[][] maze2d = new int[rows][columns];
			
			for (int i = 0; i < rows; i++) {
				for (int j = 0; j < columns; j++) {
					maze2d[i][j] = this.getValue(z, i, j);
				}
			}
			
			return maze2d;
		}else{
			throw(new IndexOutOfBoundsException("Value is not in bounds"));
		}
	}
	
	public void setStartPosition(Position startPosition) {
		this.start = startPosition;
		this.setFree(startPosition);
	}
	public void setGoalPosition(Position goalPosition) {
		this.goal = goalPosition;
	}
	public void setWall(int level, int row, int col){
		this.maze3d[level][row][col] = WALL;
	}
	public void setWall(Position pos){
		this.maze3d[pos.getLevel()][pos.getRow()][pos.getColm()] = WALL;
	}
	public void setFree(int level, int row, int col){
		this.maze3d[level][row][col] = FREE;
	}
	public void setFree(Position pos){
		this.maze3d[pos.getLevel()][pos.getRow()][pos.getColm()] = FREE;
	}
	public void setMaze3d(int[][][] maze3d) {
		this.maze3d = maze3d;
	}
	public void setValue(int level, int row, int col, int value){
		this.maze3d[level][row][col] = value;
	}
	
	public byte[] toByteArray(){
		byte[] array = new byte[(3*3)+(levels*rows*columns)];
		array[0] = (byte) levels;
		array[1] = (byte) rows;
		array[2] = (byte) columns;
		array[3] = (byte) start.getLevel();
		array[4] = (byte) start.getRow();
		array[5] = (byte) start.getColm();
		array[6] = (byte) goal.getLevel();
		array[7] = (byte) goal.getRow();
		array[8] = (byte) goal.getColm();
		int count = 9;
		for(int l = 0; l < levels; l++){
			for(int r = 0; r < rows; r++){
				for(int c = 0; c < columns; c++){
					array[count]=(byte)maze3d[l][r][c];
					count++;
				}
			}
		}
		
		return array;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		for (int h = 0; h < this.levels; h++){
			sb.append("\n\n");
			
			for (int i = 0; i < this.rows; i++) {
				for (int j = 0; j < this.columns; j++) {
					if(h == start.getLevel() && i == start.getRow() && j == start.getColm())
						sb.append("S ");
					else if(h == goal.getLevel() && i == goal.getRow() && j == goal.getColm())
						sb.append("X ");
					else
						sb.append(this.maze3d[h][i][j] + " ");
				}
				sb.append("\n");
			}
		}
		
		return sb.toString();
	}
	
}
